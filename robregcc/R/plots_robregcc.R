
#' Plot residuals estimate from robregcc object
#'
#' S3 methods extracting residuals from the objects generated by
#' \code{robregcc}. 
#'
#' @name plot_resid
#'
#' @param object Object generated by \code{robregcc}.
#' @param type 0/1 residual estimate before/after sanity check
#' @param s 0/1 no/yes 1se rule
#' @return plot estimated residual 
#' @export
#' @examples  
#' @examples  
#' \dontrun{
#' # fit.ada, fit.soft, fit.hard are fitted object from the sparse version of the robregcc model
#' 
#' plot_resid.robregcc(fit.ada)
#' plot_resid.robregcc(fit.soft)
#' plot_resid.robregcc(fit.hard)
#' }
plot_resid <- function(object, type = 0,  s = 1) {
  NextMethod("plot_resid", object, type, s)
}


#' @rdname plot_resid
#' @importFrom graphics plot
#' @export
plot_resid.robregcc = function(object, type = 1, s = 1) {
  ## add line separating outlier from inlier
  if (type == 0) {
    plot(object$residuals0[, s + 1],
         xlab = "Index", ylab = "Residuals",
         main = "Residuals plot",
         col = (!object$tData[, s + 1]) + 1
    )
  } else {
    plot(object$residualsE[, s + 1],
         xlab = "Index", ylab = "Residuals",
         main = "Residuals plot",
         col = (!object$trueDataInd[, s + 1]) + 1
    )
  }
}



#' Plot solution path at different value of lambda
#'
#' S3 methods plotting solution path of model parameter and mean shift using the object obtained from \code{robregcc}. 
#'
#' @name plot_path
#'
#' @param object Object generated by \code{robregcc}.
#' @param ptype path type 0/1 for Gamma/Beta path respectvely
#' @return plot solution path
#' @export
#' @examples  
#' \dontrun{
#' # fit.ada, fit.soft, fit.hard are fitted object from the sparse version of the robregcc model
#' 
#' plot_path(fit.ada)
#' plot_path(fit.soft)
#' plot_path(fit.hard)
#' }
plot_path = function(object, ptype = 0) {
  NextMethod("plot_path", object,  ptype = 0)
}



#' @importFrom graphics abline
#' @importFrom graphics arrows
#' @importFrom graphics axis
#' @importFrom graphics matplot
#' @importFrom graphics par
#' @importFrom graphics plot
#' @rdname plot_path
#' @export
plot_path.robregcc <- function(object, ptype = 0) {
    gind <- ((apply(abs(object$gammapath) > 0, 2, sum) != 0) *
               (apply(abs(object$betapath) > 0, 2, sum) != 0)) != 0
    gind <- which(gind)
    Gamma <- object$gammapath[, gind]
    Beta <- object$betapath[, gind]
    Lambda <- object$lampath # cv[gind]
    xls <- object$lampath[object$selInd]
    
    xl <- abs(log(Lambda / max(Lambda)))
    xl <- xl[gind]
    xls <- abs(log(xls / max(Lambda)))
    
    # par(mfrow=c(2,1))
    if (ptype == 0) {
      matplot(xl, t(Gamma),
              main = "Soluton path",
              lty = 1, type = "l",
              xlab = expression("| log(" * lambda / lambda [max] ~ ") |"),
              ylab = expression(gamma)
      )
      abline(v = xls, lty = 3)
    } else {
      matplot(xl, t(Beta),
              main = "Soluton path",
              lty = 1, type = "l",
              xlab = expression("| log(" * lambda / lambda [max] ~ ") |"),
              ylab = expression(beta)
      )
      abline(v = xls, lty = 3)
    }
}



#' Plot cross-validation error plot
#'
#' S3 methods plotting crossvalidation error using the object obtained from \code{robregcc}. 
#'
#' @name plot_cv
#'
#' @param object robregcc fitted onject
#' @return generate cv error plot
#' @export
#' @examples  
#' @examples  
#' \dontrun{
#' # fit.ada, fit.soft, fit.hard are fitted object from the sparse version of the robregcc model
#' 
#' plot_cv(fit.ada)
#' plot_cv(fit.soft)
#' plot_cv(fit.hard)
#' }
plot_cv = function(object) {
  NextMethod("plot_cv", object)
}





#' @importFrom graphics abline
#' @importFrom graphics arrows
#' @importFrom graphics axis
#' @importFrom graphics matplot
#' @importFrom graphics par
#' @importFrom graphics plot
#' @rdname plot_cv
#' @export
plot_cv.robregcc <- function(object) {
  gind <- ((apply(abs(object$gammapath) > 0, 2, sum) != 0) *
             (apply(abs(object$betapath) > 0, 2, sum) != 0)) != 0
  avger <- apply(object$cver, 2, mean, na.rm = T)
  avger <- avger * gind
  avger[avger == 0] <- NA
  
  sderr <- apply(object$cver, 2, sd, na.rm = T) / sqrt(nrow(object$cver))
  sderr <- sderr * gind
  sderr[sderr == 0] <- NA
  
  xls <- object$lampathcv[object$selInd]
  Lambda <- object$lampathcv
  xl <- abs(log(Lambda / max(Lambda)))
  gind <- which(gind)
  xl <- xl[gind]
  xls <- abs(log(xls / max(Lambda)))
  
  avger <- avger[gind]
  sderr <- sderr[gind]
  Index <- 1:length(object$lampathcv)
  dm <- range(avger)
  plot(xl, avger,
       main = "Cross-validation error",
       type = "o", ylab = "CV Error", col = 2,
       ylim = c(0, 5 * dm[2] / 4),
       xlab = expression("| log(" * lambda / lambda [max] ~ ") |")
  )
  arrows(xl, avger - sderr, xl,
         avger + sderr,
         length = 0.05, angle = 90, code = 3
  )
  # axis(
  #   side = 3, at = xl, labels = paste(Index[gind]),
  #   tick = FALSE, line = 0
  # )
  abline(v = xls, lty = 3)
}


